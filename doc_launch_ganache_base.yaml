_bbsfin: &bbsfin
  - '0x627306090abab3a6e1400e9345bc60c78a8bef57'
_bbstech: &bbstech
  - '0x627306090abab3a6e1400e9345bc60c78a8bef57'

local:
  chain: local
  verify_on_etherscan: no
  browser_driver: chrome

  solc:
    # This is the Solidity version tag we verify on EtherScan.
    # For available versions see
    # https://kovan.etherscan.io/verifyContract2
    #
    # See values in Compiler drop down.
    # You can also get the local compiler version with:
    #
    #     solc --version
    #
    # Note that for EtherScan you need to add letter "v" at the front of the version
    #
    # Note: You need to have correct optmization settings for the compiler
    # in populus.json that matches what EtherScan is expecting.
    #
    version: v0.4.18+commit.9cf6e910

    #
    # We supply these to EtherScan as the solc settings we used to compile the contract.
    # They must match values in populus.json compilication / backends section.
    #
    optimizations:
      optimizer: true
      runs: 500   


  contracts:
    # This is the address of the multisig wallet where the paymnts eventually land
    command_wallet:
      contract_name: MultiSigWallet
      contract_file: GnosisWallet.sol
      arguments:
        # TODO real count, real owners
        _required: 1
        _owners: *bbstech

    #
    # Token contract
    #
    # This contract represents ERC-20 token.
    # It has transfer lock up functionality to prevent the token to be transferable
    # until the ICO is overe
    #
    # We create the whole token supply upfront and no more token minting
    # happens ever.
    #
    # Token has 18 decimals and supply of 1B tokens.
    #
    # Token supply is one billion tokens.
    #
    # Name and symbol are not set yet. They are set later. In
    # the case of the deployment fails and we need redeploy
    # we do not create unnecessary entries in token explorers.
    #
    token:
      contract_name: BurnableCrowdsaleToken
      contract_file: BurnableCrowdsaleToken.sol
      arguments:
        _name: ''
        _symbol: ''
        _initialSupply: '{{ 100000000*10**18 }}'
        _decimals: 18
        _mintable: false   

    #
    # Pricing strategy.
    #
    # We use ETH tranches. People who buy in in the first
    # tranches get 20% and 10% bonus tokens.
    #
    pricing_strategy:
      contract_name: TokenTranchePricing
      contract_file: TokenTranchePricing.sol
      arguments:
        _tranches:
          - 0
          - 128571428571428

          - "{{ to_wei('1400000', 'ether') }}"
          - 138846153846153

          - "{{ to_wei('4000000', 'ether') }}"
          - 150277777777777

          - "{{ to_wei('7600000', 'ether') }}"
          - 164090909090909

          - "{{ to_wei('12000000', 'ether') }}"
          - 180382352941176

          # Dummy milestone marker to mark the end
          # of the array.
          - "{{ to_wei('99999999999999999', 'ether') }}"
          - 0

    #
    # Crowdsale.
    #
    # We use allocated crowdsale as the whole token supply has been created beforehand.
    # No minting. Later we use approve() to give tokens for this contract to be sold.
    #
    crowdsale:
      contract_name: AllocatedCrowdsale
      contract_file: AllocatedCrowdsale.sol  # Changes here to multiple multi sigs
      arguments:
        _token: '{{ contracts.token.address }}'
        _pricingStrategy: '{{ contracts.pricing_strategy.address }}'
        _multisigWallet: '{{ contracts.command_wallet.address }}'
        _start: 1  # TODO real block
        _end: 999999999999  # TODO real block
        _minimumFundingGoal: 0
        _beneficiary: '{{ deploy_address }}'

    #
    # Because deploy_address controls whole supply,
    # we do not create any supply dynamically,
    # we do not need a finalizer.
    #
    finalize_agent:
      contract_name: NullFinalizeAgent
      contract_file: NullFinalizeAgent.sol
      arguments:
        _crowdsale: '{{ contracts.crowdsale.address }}'


  # Post-deployment actions connect contracts together.
  post_actions: |
    # Allow crowdsale contract to sell its token
    token.transact({"from": deploy_address}).approve(crowdsale.address, 0)
    token.transact({"from": deploy_address}).approve(crowdsale.address, 100000000*10**18)

    # Make sure crowdsale contract and these accounts
    # can transfer tokens despite transfer lock up
    token.transact({"from": deploy_address}).setTransferAgent(command_wallet.address, True)
    token.transact({"from": deploy_address}).setTransferAgent(crowdsale.address, True)
    token.transact({"from": deploy_address}).setTransferAgent(finalize_agent.address, True)
    token.transact({"from": deploy_address}).setTransferAgent(deploy_address, True)

    # Do not do nothing at the end of the crowdsale
    confirm_tx(crowdsale.transact({"from": deploy_address}).setFinalizeAgent(finalize_agent.address))

    # Owner can release the token transfer when they fel its the time
    confirm_tx(token.transact({"from": deploy_address}).setReleaseAgent(command_wallet.address))

    # Set token upgrade master to team multisig to give the new token path
    confirm_tx(token.transact({"from": deploy_address}).setUpgradeMaster(command_wallet.address))

    # Allow test buys from these accounts before token sale begins.
    confirm_tx(crowdsale.transact({"from": deploy_address}).setEarlyParicipantWhitelist(deploy_address, True))

    # Allow deploy address to buy
    confirm_tx(crowdsale.transact({"from": deploy_address}).setKycWhitelist(deploy_address, True))

    # Set the min transactions to prevent tranche-busting
    confirm_tx(crowdsale.transact({"from": deploy_address}).setTrancheMinTx(10))

    # Set the min transactions to prevent tranche-busting
    confirm_tx(crowdsale.transact({"from": deploy_address}).setMaximumPurchaseFraction(476))

    w = ['0xf17f52151EbEF6C7334FAD080c5704D77216b732','0xC5fdf4076b8F3A5357c5E395ab970B5B54098Fef','0x821aEa9a577a9b44299B9c15c88cf3087F3b5544','0x0d1d4e623D10F9FBA5Db95830F7d3839406C6AF2']
    for ww in w: confirm_tx(crowdsale.transact({"from": deploy_address}).setKycWhitelist(ww, True))


  # Sanity check
  verify_actions: |
    assert token.call().owner().lower() == deploy_address.lower()
    assert token.call().released() == False
    assert crowdsale.call().owner().lower() == deploy_address.lower()
    assert crowdsale.call().multisigWallet().lower() == command_wallet.address.lower()
    assert finalize_agent.call().isSane()
    # TODO switch to CrowdsaleState.PreFunding
    #assert crowdsale.call().getState() == CrowdsaleState.PreFunding   # PreFunding for the final, as it is deployed pre-opening
    assert crowdsale.call().getState() == CrowdsaleState.Funding
    assert crowdsale.call().trancheMinTx() == 10
    assert crowdsale.call().maximumPurchaseFraction() == 476

    tx_gas = 400000

    # Do a test buy using a test address.
    # This ensures are variables are set and the
    # funds flow in the multisig wallet.
    #confirm_tx(crowdsale.transact({"from": deploy_address, 'gas': tx_gas, "value": to_wei("0.01", "ether")}).buy())

    w = ['0xf17f52151EbEF6C7334FAD080c5704D77216b732','0xC5fdf4076b8F3A5357c5E395ab970B5B54098Fef','0x821aEa9a577a9b44299B9c15c88cf3087F3b5544','0x0d1d4e623D10F9FBA5Db95830F7d3839406C6AF2']

    confirm_tx(crowdsale.transact({"from": w[0], 'gas': tx_gas, "value": to_wei("1", "ether")}).buy())
    assert token.call().balanceOf(w[0]) > 0

    for _ in range(10): confirm_tx(crowdsale.transact({"from": w[1], 'gas': tx_gas, "value": to_wei("9", "ether")}).buy())
    assert token.call().balanceOf(w[1]) > 0

    for _ in range(10): confirm_tx(crowdsale.transact({"from": w[2], 'gas': tx_gas, "value": to_wei("9", "ether")}).buy())
    assert token.call().balanceOf(w[2]) <= token.call().balanceOf(w[1])

    confirm_tx(crowdsale.transact({"from": w[3], 'gas': tx_gas, "value": to_wei("1", "ether")}).buy())
    assert token.call().balanceOf(w[3]) > 0
    assert token.call().balanceOf(w[3]) < token.call().balanceOf(w[1])

    # As the last action, after successful deployment, set the right token symbol and name so that it shows in a blockchain explorer
    confirm_tx(token.transact({"from": deploy_address, 'gas': tx_gas}).setTokenInformation("Duty of Care Token", "VDOC"))
