_bbsfin: &bbsfin
  - '0x00eC84AeC2f4fe5790728fB6BbDa1Ef6d0b30351'
_bbstech: &bbstech
  - '0x00eC84AeC2f4fe5790728fB6BbDa1Ef6d0b30351'

kovan:
  chain: kovan
  #verify_on_etherscan: yes
  #browser_driver: chrome

  solc:
    # This is the Solidity version tag we verify on EtherScan.
    # For available versions see
    # https://kovan.etherscan.io/verifyContract2
    #
    # See values in Compiler drop down.
    # You can also get the local compiler version with:
    #
    #     solc --version
    #
    # Note that for EtherScan you need to add letter "v" at the front of the version
    #
    # Note: You need to have correct optmization settings for the compiler
    # in populus.json that matches what EtherScan is expecting.
    #
    version: v0.4.18+commit.9cf6e910

    #
    # We supply these to EtherScan as the solc settings we used to compile the contract.
    # They must match values in populus.json compilication / backends section.
    #
    optimizations:
      optimizer: true
      runs: 500   


  contracts:
    # This is the address of the multisig wallet where the paymnts eventually land
    command_wallet:
      contract_name: MultiSigWallet
      contract_file: GnosisWallet.sol
      arguments:
        # TODO real count, real owners
        _required: 1
        _owners: *bbstech

    holding_wallet_01: &holding_wallet
      contract_name: MultiSigWallet
      contract_file: GnosisWallet.sol
      arguments:
        # TODO real count, real owners
        _required: 1
        _owners: *bbsfin
    holding_wallet_02:
      <<: *holding_wallet
    holding_wallet_03:
      <<: *holding_wallet
    holding_wallet_04:
      <<: *holding_wallet
    holding_wallet_05:
      <<: *holding_wallet
    holding_wallet_06:
      <<: *holding_wallet
    holding_wallet_07:
      <<: *holding_wallet
    holding_wallet_08:
      <<: *holding_wallet
    holding_wallet_09:
      <<: *holding_wallet
    holding_wallet_10:
      <<: *holding_wallet

    #
    # Token contract
    #
    # This contract represents ERC-20 token.
    # It has transfer lock up functionality to prevent the token to be transferable
    # until the ICO is overe
    #
    # We create the whole token supply upfront and no more token minting
    # happens ever.
    #
    # Token has 18 decimals and supply of 1B tokens.
    #
    # Token supply is one billion tokens.
    #
    # Name and symbol are not set yet. They are set later. In
    # the case of the deployment fails and we need redeploy
    # we do not create unnecessary entries in token explorers.
    #
    token:
      contract_name: BurnableCrowdsaleToken
      contract_file: BurnableCrowdsaleToken.sol
      arguments:
        _name: ''
        _symbol: ''
        _initialSupply: '{{ 100000000*10**18 }}'
        _decimals: 18
        _mintable: false   

    #
    # Pricing strategy.
    #
    # We use ETH tranches. People who buy in in the first
    # tranches get 20% and 10% bonus tokens.
    #
    pricing_strategy:
      contract_name: TokenTranchePricing
      contract_file: TokenTranchePricing.sol
      arguments:
        _tranches:
          - 0
          - 128571428571428

          - 21400000
          - 138846153846153

          - 2400000000
          - 150277777777777

          - 27600000
          - 164090909090909

          - 32000000
          - 180382352941176

          # Dummy milestone marker to mark the end
          # of the array.
          - 999999999999999
          - 0

    #
    # Crowdsale.
    #
    # We use allocated crowdsale as the whole token supply has been created beforehand.
    # No minting. Later we use approve() to give tokens for this contract to be sold.
    #
    crowdsale:
      contract_name: AllocatedCrowdsale
      contract_file: AllocatedCrowdsale.sol  # Changes here to multiple multi sigs
      arguments:
        _token: '{{ contracts.token.address }}'
        _pricingStrategy: '{{ contracts.pricing_strategy.address }}'
        _multisigWallets:
          - '{{ contracts.holding_wallet_01.address }}'
          - '{{ contracts.holding_wallet_02.address }}'
          - '{{ contracts.holding_wallet_03.address }}'
          - '{{ contracts.holding_wallet_04.address }}'
          - '{{ contracts.holding_wallet_05.address }}'
          - '{{ contracts.holding_wallet_06.address }}'
          - '{{ contracts.holding_wallet_07.address }}'
          - '{{ contracts.holding_wallet_08.address }}'
          - '{{ contracts.holding_wallet_09.address }}'
          - '{{ contracts.holding_wallet_10.address }}'
        _start: '1'  # TODO real block
        _end: '999999999999'  # TODO real block
        _minimumFundingGoal: '0'
        _beneficiary: '{{ deploy_address }}'

    #
    # Because deploy_address controls whole supply,
    # we do not create any supply dynamically,
    # we do not need a finalizer.
    #
    finalize_agent:
      contract_name: NullFinalizeAgent
      contract_file: NullFinalizeAgent.sol
      arguments:
        _crowdsale: '{{ contracts.crowdsale.address }}'


  # Post-deployment actions connect contracts together.
  post_actions: |
    # Allow crowdsale contract to sell its token
    token.transact({"from": deploy_address}).approve(crowdsale.address, 100000000000*10**18)

    # Make sure crowdsale contract and these accounts
    # can transfer tokens despite transfer lock up
    token.transact({"from": deploy_address}).setTransferAgent(command_multisig.address, True)
    token.transact({"from": deploy_address}).setTransferAgent(crowdsale.address, True)
    token.transact({"from": deploy_address}).setTransferAgent(finalize_agent.address, True)
    # token.transact({"from": deploy_address}).setTransferAgent(deploy_address, True)

    # Preallocate foundation tokens to holding wallets
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_01.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_02.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_03.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_04.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_05.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_06.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_07.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_08.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_09.address, 2000000, 0))
    confirm_tx(crowdsale.transact({"from": deploy_address}).preallocate(holding_wallet_10.address, 2000000, 0))

    # Do not do nothing at the end of the crowdsale
    confirm_tx(crowdsale.transact({"from": deploy_address}).setFinalizeAgent(finalize_agent.address))

    # Owner can release the token transfer when they fel its the time
    confirm_tx(token.transact({"from": deploy_address}).setReleaseAgent(command_multisig.address))

    # Set token upgrade master to team multisig to give the new token path
    confirm_tx(token.transact({"from": deploy_address}).setUpgradeMaster(command_multisig.address))

    # Allow test buys from these accounts before token sale begins.
    confirm_tx(crowdsale.transact({"from": deploy_address}).setEarlyParicipantWhitelist(deploy_address, True))


  # Sanity check
  verify_actions: |
    assert token.call().owner().lower() == deploy_address.lower()
    assert token.call().released() == False
    assert crowdsale.call().owner().lower() == deploy_address.lower()
    assert crowdsale.call().multisigWallet().lower() == command_multisig.address.lower()
    assert finalize_agent.call().isSane()
    # TODO switch to CrowdsaleState.PreFunding
    #assert crowdsale.call().getState() == CrowdsaleState.PreFunding   # PreFunding for the final, as it is deployed pre-opening
    assert crowdsale.call().getState() == CrowdsaleState.Funding

    # Do a test buy using a test address.
    # This ensures are variables are set and the
    # funds flow in the multisig wallet.
    confirm_tx(crowdsale.transact({"from": deploy_address, "value": to_wei("0.01", "ether")}).buy())

    # As the last action, after successful deployment, set the right token symbol and name so that it shows in a blockchain explorer
    # TODO different name
    confirm_tx(token.transact({"from": deploy_address}).setTokenInformation("Duty of Care Token", "DOC"))
